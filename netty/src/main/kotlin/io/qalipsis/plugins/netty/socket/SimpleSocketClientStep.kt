/*
 * Copyright 2022 AERIS IT Solutions GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package io.qalipsis.plugins.netty.socket

import io.netty.channel.EventLoopGroup
import io.qalipsis.api.context.MinionId
import io.qalipsis.api.context.StepContext
import io.qalipsis.api.context.StepName
import io.qalipsis.api.context.StepStartStopContext
import io.qalipsis.api.events.EventsLogger
import io.qalipsis.api.lang.tryAndLogOrNull
import io.qalipsis.api.logging.LoggerHelper.logger
import io.qalipsis.api.meters.CampaignMeterRegistry
import io.qalipsis.api.retry.RetryPolicy
import io.qalipsis.api.steps.AbstractStep
import io.qalipsis.plugins.netty.EventLoopGroupSupplier
import io.qalipsis.plugins.netty.exceptions.ClosedClientException
import io.qalipsis.plugins.netty.monitoring.StepContextBasedSocketMonitoringCollector
import io.qalipsis.plugins.netty.tcp.ConnectionAndRequestResult
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit
import kotlinx.coroutines.withContext
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger
import kotlin.coroutines.CoroutineContext

/**
 * Parent class of steps using a implementations of [SocketClient]s created individually for each minion.
 *
 * @param I type of the input of the step
 * @param O type of the output of the step
 * @param CONF type of the configuration of the client
 * @param REQ type of the request processed by the client (and generated from I)
 * @param RES type of the response generated by the client (and later converted to O)
 * @param CLI type of the client
 *
 * @author Eric Jess√©
 */
internal abstract class SimpleSocketClientStep<I, O : Any, CONF : SocketClientConfiguration, REQ : Any, RES : Any, CLI : SocketClient<CONF, REQ, RES, CLI>>(
    id: StepName,
    retryPolicy: RetryPolicy?,
    private val ioCoroutineContext: CoroutineContext,
    private val requestFactory: suspend (StepContext<*, *>, I) -> REQ,
    private val configuration: CONF,
    private val stepQualifier: String,
    private val eventLoopGroupSupplier: EventLoopGroupSupplier,
    private val eventsLogger: EventsLogger?,
    private val meterRegistry: CampaignMeterRegistry?
) : AbstractStep<I, ConnectionAndRequestResult<I, O>>(id, retryPolicy),
    SocketClientStep<I, REQ, RES, ConnectionAndRequestResult<I, O>> {

    /**
     * Maintains the number of steps actually using the same connection.
     * Default is 1, considering the present step.
     */
    protected val usagesCount = AtomicInteger(1)

    private var running = false

    /**
     * Long-live client contexts to reuse the connection between different steps.
     */
    protected val clients = ConcurrentHashMap<MinionId, Channel<CLI>>()

    /**
     * Semaphores to avoid concurrent creation of a client for the same minion.
     */
    private val minionsSemaphores = ConcurrentHashMap<MinionId, Semaphore>()

    /**
     * Clients that are currently being used, in order to keep a reference to them to close them.
     */
    protected val clientsInUse = ConcurrentHashMap<MinionId, CLI>()

    protected lateinit var workerGroup: EventLoopGroup

    override suspend fun start(context: StepStartStopContext) {
        workerGroup = eventLoopGroupSupplier.getGroup()
        running = true
    }

    @Throws(SocketException::class)
    override suspend fun execute(context: StepContext<I, ConnectionAndRequestResult<I, O>>) {
        log.trace { "Creating the monitoring collector" }
        val monitoringCollector = createMonitoringCollector(context)
        log.trace { "Receiving the input" }
        val input = context.receive()
        log.trace { "Executing the request" }
        val response = withContext(ioCoroutineContext) {
            execute(monitoringCollector, context, input, requestFactory(context, input))
        }
        log.trace { "Converting the response into result" }
        val result = monitoringCollector.toResult(input, convertResponseToOutput(response), null)
        if (result.isFailure) {
            throw SocketRequestException(result)
        }
        context.send(result)
    }

    /**
     * Converts the response from the client into the output of the step.
     */
    @Suppress("UNCHECKED_CAST")
    open fun convertResponseToOutput(response: RES): O = response as O

    protected open fun createMonitoringCollector(context: StepContext<I, ConnectionAndRequestResult<I, O>>) =
        StepContextBasedSocketMonitoringCollector(context, eventsLogger, meterRegistry, stepQualifier)

    @Throws(SocketException::class)
    override suspend fun <IN> execute(
        monitoringCollector: StepContextBasedSocketMonitoringCollector,
        context: StepContext<*, *>, input: IN, request: REQ
    ): RES {
        return doExecute(monitoringCollector, context, input, request)
    }

    /**
     * Executes a request and reads the response from the server.
     * If a client exists and is open, it is reused, otherwise a new one is created.
     */
    @Throws(SocketException::class)
    protected suspend fun <IN> doExecute(
        monitoringCollector: StepContextBasedSocketMonitoringCollector,
        context: StepContext<*, *>, input: IN, request: REQ
    ): RES {
        require(running) { "The step $name is not running" }

        val client = try {
            log.trace { "Acquiring the semaphore to create or acquire the client for the context $context" }
            minionsSemaphores.computeIfAbsent(context.minionId) { Semaphore(1, 0) }.withPermit {
                createOrAcquireClient(monitoringCollector, context)
            }
        } catch (e: Exception) {
            clients.remove(context.minionId)?.close()
            clientsInUse.remove(context.minionId)
            minionsSemaphores.remove(context.minionId)

            throw e.takeIf { e is SocketException } ?: SocketConnectionException(
                monitoringCollector.toResult(input, null, e.takeUnless { monitoringCollector.cause == e })
            )
        }

        return try {
            client.execute(context, request, monitoringCollector)
        } catch (e: Exception) {
            client.close()
            // The exception is only considered if not already set in the context.
            throw e.takeIf { e is SocketException } ?: SocketException(
                monitoringCollector.toResult(input, null, e.takeUnless { monitoringCollector.cause === e })
            )
        } finally {
            clientsInUse.remove(context.minionId)
            if (client.isOpen) {
                log.trace { "Putting the client back to the queue" }
                clients[context.minionId]?.send(client)
                if (context.isTail && (!configuration.keepConnectionAlive && client.isExhausted())) {
                    client.close()
                }
            } else {
                log.trace { "Discarding the dirty client" }
                clients.remove(context.minionId)?.close()
            }
        }
    }

    /**
     * Creates a new client of acquires it if it already exists.
     */
    suspend fun createOrAcquireClient(
        monitoringCollector: StepContextBasedSocketMonitoringCollector,
        context: StepContext<*, *>
    ): CLI {
        return if (clients.containsKey(context.minionId)) {
            log.trace { "Reusing the client for the context $context" }
            // Reuse the client if it exists for the same minion.
            acquireClient(context.minionId)
        } else {
            log.trace { "Creating a new client for the context $context" }
            // Set it empty so that the next call with the same minion waits for it.
            clients[context.minionId] = Channel(1)
            createClient(context.minionId, monitoringCollector).also { clientsInUse[context.minionId] = it }
        }.also {
            log.trace { "Client was obtained for the context $context" }
        }
    }

    /**
     * Acquires an existing [CLI] for the specified [minionId], throwing an exception if it does not exist or is not open.
     */
    private suspend fun acquireClient(minionId: MinionId): CLI {
        log.trace { "Acquiring client from ${clients[minionId]}" }
        val client = clients[minionId]?.receiveCatching()?.getOrThrow()?.let {
            if (!it.isOpen) {
                clients.remove(minionId)?.close()
                null
            } else {
                it
            }
        } ?: throw ClosedClientException(minionId)

        clientsInUse[minionId] = client
        return client
    }

    abstract protected suspend fun createClient(
        minionId: MinionId,
        monitoringCollector: StepContextBasedSocketMonitoringCollector
    ): CLI

    /**
     * Keeps the connections open, waiting for a later step to close them manually.
     */
    override fun keepOpen() {
        configuration.keepConnectionAlive = true
    }

    /**
     * Closes the connection if not yet done.
     */
    override suspend fun close(minionId: MinionId) {
        acquireClient(minionId).close()
    }

    /**
     * Add a further step as a user of the same connection.
     */
    override fun addUsage(count: Int) {
        usagesCount.addAndGet(count)
    }

    override suspend fun stop(context: StepStartStopContext) {
        running = false
        clients.values.forEach {
            kotlin.runCatching {
                if (!it.isEmpty) {
                    it.receiveCatching().getOrThrow().close()
                }
                it.cancel()
            }
        }
        clients.clear()

        clientsInUse.values.forEach { tryAndLogOrNull(log) { it.close() } }
        clientsInUse.clear()
        minionsSemaphores.clear()
        workerGroup.shutdownGracefully()
    }


    companion object {
        @JvmStatic
        private val log = logger()
    }
}
